/**
Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal
and D = |Pk − Pj| is minimised; what is the value of D?
TODO: I think there is more efficient solution by precomputing all pentagon diffs that result in pentagons
then from there finding those that sum.
 */
/********************* Header Files ***********************/
/* C++ Headers */
#include <iostream> /* Input/output objects. */
#include <iomanip>
#include <fstream>
#include <sstream>
#include <exception>
#include <initializer_list>
#include <map>
#include <set>
#include <deque>
#include <algorithm>
#include <iterator>
#include <cstdlib>
#include <numeric>
#include <limits>

#include "gtest/gtest.h"
#include "util.hpp"
#include "gmpxx.h"
#include "gmp.h"

/**************** Namespace Declarations ******************/
using std::cout;
using std::endl;

/************** Global Vars & Functions *******************/
typedef long num_t;
typedef std::map<num_t, num_t> map_t;

class ValueError : public std::exception {
public:
    explicit ValueError(const std::string &msg) : msg(msg) { }
    const char * what() const throw() {
        return msg.c_str();
    }

    // Data
    std::string msg;
};

class NPair {
public:
    num_t first;
    num_t second;
};

class Maps {
public:
    num_t add_pentagon(num_t index);
    num_t get_pentagon(num_t index);
    void fill_pentagons(num_t limit);
    bool pentagon_exists(num_t target_pentagon, num_t first_index);
    num_t check_pair(const NPair &pair);
    inline
    num_t max() { return get_pentagon(max_index); }
    bool is_pentagon(num_t target_pentagon);

    // Data
    map_t index_to_pentagons;
    map_t pentagons_to_index;
    num_t max_index = 1;
};

std::ostream& operator<<(std::ostream& os, const NPair &pair) {
    os << pair.first << "," << pair.second;

    return os;
}

inline
num_t pentagon_number(long index) {
    if (index < 1) {
        throw ValueError("Pentagon numbers start at 1.");
    }
    return index * (3 * index - 1) * 1/2;
}

inline
num_t Maps::add_pentagon(num_t index) {
    num_t pentagon = pentagon_number(index);
    index_to_pentagons[index] = pentagon;
    pentagons_to_index[pentagon] = index;

    if (index > max_index) {
        max_index = index;
    }

    return pentagon;
}

inline
num_t Maps::get_pentagon(num_t index) {
    try {
        return index_to_pentagons.at(index);
    } catch (std::out_of_range const&) {
        return add_pentagon(index);
    }
}

// Fill up to and including the index of limit.
inline
void Maps::fill_pentagons(num_t limit = 100) {
    for (num_t ind = 1; ind <= limit; ++ind) {
        add_pentagon(ind);
    }
}

/**
 * @brief This function determines if a pentagon number exists for that value.
 *
 * @param target_pentagon The pentagon number to look for.
 * @param first_index The first new index possible to match with.
 * @param index_to_pentagons The map of index to pentagon numbers.
 * @param pentagons_to_index The map of pentagon numbers to their index positions.
 * @return Bool true IFF the target_pentagon is a pentagon number.
 */
bool Maps::pentagon_exists(num_t target_pentagon, num_t first_index) {
    bool found_match = false;

    num_t next_pentagon = get_pentagon(first_index);
    while (next_pentagon <= target_pentagon) {
        if (next_pentagon == target_pentagon) {
            found_match = true;
            break;
        }

        ++first_index;
        next_pentagon = get_pentagon(first_index);
    }

    return found_match;
}

// Check if the pair follows the required rules:
//  1) Difference of pentagon numbers, is a pentagon.
//  2) Sum of the pentagons is a pentagon.
//
//  When satisfied, return the difference.
//  When a check fails, raise ValueError.
num_t Maps::check_pair(const NPair &pair) {
    num_t found_pentagon = 0;
    if (pair.first > pair.second) {
        throw ValueError("pair.first was greater than pair.second");
    }

    // Check if diff pentagonal.
    num_t diff = pair.second - pair.first;
    try {
        found_pentagon = pentagons_to_index.at(diff);
    } catch (std::out_of_range const&) {
        throw ValueError("pair.second - pair.first was NOT pentagonal.");
    }

    // Check if sum pentagonal.
    num_t sum = pair.second + pair.first;
    try {
        found_pentagon = pentagons_to_index.at(sum);
    } catch (std::out_of_range const&) {
        num_t last_index = pentagons_to_index.at(pair.second);

        if (!pentagon_exists(sum, last_index)) {
            throw ValueError("pair.second + pair.first was NOT pentagonal.");
        }
    }
    cout << "Pentagon sum: " << pair.second << " + " << pair.first << " = " << sum << endl;
    cout << "Pentagon diff: " << pair.second << " - " << pair.first << " = " << diff << endl;

    return diff;
}

NPair find_pentagonal_pair() {
    NPair best_pair = {0, 0};
    num_t best_diff = 0, index = 2;
    Maps map;
    map.add_pentagon(1);

    // Add one new pentagon every pass.
    // For every added pentagon, check every pairing with existing previous pentagons.
    // When a matching pair is found by check_pair, record it in best_pair.
    while (index <= 2500) {
        num_t new_pentagon = map.add_pentagon(index);
        for (int i = 1; i < index; ++i) {
            try {
                NPair pair = {map.get_pentagon(i), new_pentagon};
                // cout << pair << endl;
                num_t check_diff = map.check_pair(pair);
                if (check_diff < best_diff || best_diff == 0) {
                    best_pair = pair;
                }
            } catch (const ValueError &e) {
                // Pass
            }
        }

        ++index;
    };

    return best_pair;
}

TEST(Euler044, PentagonNumber) {
    ASSERT_EQ(pentagon_number(7), 70);
    ASSERT_EQ(pentagon_number(4), 22);
    EXPECT_THROW(pentagon_number(0), ValueError);
    EXPECT_THROW(pentagon_number(-1), ValueError);
}

TEST(Euler044, AddPentagon) {
    Maps map;

    map.add_pentagon(1);
    map.add_pentagon(2);

    ASSERT_EQ(map.index_to_pentagons.at(1), 1);
    ASSERT_EQ(map.index_to_pentagons.at(2), 5);
    ASSERT_EQ(map.pentagons_to_index.at(1), 1);
    ASSERT_EQ(map.pentagons_to_index.at(5), 2);
}

TEST(Euler044, GetPentagon) {
    Maps map;

    map.add_pentagon(1);
    map.add_pentagon(2);

    ASSERT_EQ(map.get_pentagon(2), 5);
    ASSERT_EQ(map.get_pentagon(3), 12);
}

TEST(Euler044, PentagonExists) {
    Maps map;
    map.add_pentagon(1);
    map.add_pentagon(2);

    ASSERT_TRUE(map.pentagon_exists(12, 2));
    ASSERT_FALSE(map.pentagon_exists(99, 2));
}

// TODO: More testing.
TEST(Euler044, CheckPairFail) {
    Maps map;

    NPair pentagons = {5, 1};
    EXPECT_THROW(map.check_pair(pentagons), ValueError);
}

TEST(Euler044, FinalSolution) {
    auto result = find_pentagonal_pair();
    cout << "The pair of pentagonal numbers is: (" << result.first << ", " << result.second << ")" << endl
        << "The sum is a pentagon: " << result.first + result.second << endl
        << "The difference is a pentagon and minimal (largest - smallest): " << result.second - result.first << endl;
    auto diff = result.second - result.first;
    ASSERT_EQ(diff, 5482660);
}
