/**
Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
Triangle 	  	Tn=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Pentagonal 	  	Pn=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	Hn=n(2n−1) 	  	1, 6, 15, 28, 45, ...

It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.

 */
/********************* Header Files ***********************/
/* C++ Headers */
#include <iostream> /* Input/output objects. */

#include "gtest/gtest.h"

/**************** Namespace Declarations ******************/
using std::cout;
using std::endl;

/************** Global Vars & Functions *******************/
class Generator {
public:
    Generator(long index = 0) : index(index) {};
    virtual ~Generator() {};
    virtual long next() = 0;

    //Data
    long index = 0;
    long current = 0;
};

class TriangleGen : public Generator {
public:
    explicit TriangleGen(long index = 0) : Generator(index) {}
    long next() override {
        index++;
        current = index * (index + 1) / 2;
        return current;
    }
};

class PentagonalGen : public Generator {
public:
    explicit PentagonalGen(long index = 0) : Generator(index) {}
    long next() override {
        index++;
        current = index * (3 * index - 1) / 2;
        return current;
    }
};

class HexagonalGen : public Generator {
public:
    explicit HexagonalGen(long index = 0) : Generator(index) {}
    long next() override {
        index++;
        current = index * (2 * index - 1);
        return current;
    }
};

long search_nums() {
    TriangleGen triangles(284);
    PentagonalGen pentagons(164);
    HexagonalGen hexagons(142);

    cout << "Starting at last known intersection:" << endl;
    cout << triangles.next() << " == " << pentagons.next() << " == " << hexagons.next() << endl;
    hexagons.next();

    // Loop until the next intersection, it is assumed that such an intersection exists.
    while (true) {
        cout << triangles.current << " == " << pentagons.current << " == " << hexagons.current << endl;

        while (triangles.current < hexagons.current) {
            triangles.next();
        };

        while (pentagons.current < hexagons.current) {
            pentagons.next();
        };

        // Check if intersected, otherwise increment hexagons.
        if (triangles.current == pentagons.current && pentagons.current == hexagons.current) {
            break;
        }

        hexagons.next();
    };

    cout << "The newly found intersection:" << endl;
    cout << triangles.index << " == " << pentagons.index << " == " << hexagons.index << endl;
    cout << triangles.current << " == " << pentagons.current << " == " << hexagons.current << endl;

    return triangles.current;
}

TEST(Euler045, TriangleGen) {
    TriangleGen gen;
    ASSERT_EQ(gen.next(), 1);
    ASSERT_EQ(gen.next(), 3);
    ASSERT_EQ(gen.next(), 6);
    ASSERT_EQ(gen.next(), 10);
}

TEST(Euler045, PentagonalGen) {
    PentagonalGen gen;
    ASSERT_EQ(gen.next(), 1);
    ASSERT_EQ(gen.next(), 5);
    ASSERT_EQ(gen.next(), 12);
    ASSERT_EQ(gen.next(), 22);
}

TEST(Euler045, HexagonalGen) {
    HexagonalGen gen;
    ASSERT_EQ(gen.next(), 1);
    ASSERT_EQ(gen.next(), 6);
    ASSERT_EQ(gen.next(), 15);
    ASSERT_EQ(gen.next(), 28);
}

TEST(Euler045, FinalSolution) {
    int result = search_nums();
    ASSERT_EQ(result, 1533776805);
    cout << "The next intersection of triangle, pentagon and hexagonal numbers: " << result << endl;
}
